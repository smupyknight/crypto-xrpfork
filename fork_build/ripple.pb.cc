// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ripple.proto

#include "ripple.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace protocol {
class TMManifestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMManifest>
      _instance;
} _TMManifest_default_instance_;
class TMManifestsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMManifests>
      _instance;
} _TMManifests_default_instance_;
class TMProofWorkDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMProofWork>
      _instance;
} _TMProofWork_default_instance_;
class TMHelloDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMHello>
      _instance;
} _TMHello_default_instance_;
class TMClusterNodeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMClusterNode>
      _instance;
} _TMClusterNode_default_instance_;
class TMLoadSourceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMLoadSource>
      _instance;
} _TMLoadSource_default_instance_;
class TMClusterDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMCluster>
      _instance;
} _TMCluster_default_instance_;
class TMTransactionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMTransaction>
      _instance;
} _TMTransaction_default_instance_;
class TMStatusChangeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMStatusChange>
      _instance;
} _TMStatusChange_default_instance_;
class TMProposeSetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMProposeSet>
      _instance;
} _TMProposeSet_default_instance_;
class TMHaveTransactionSetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMHaveTransactionSet>
      _instance;
} _TMHaveTransactionSet_default_instance_;
class TMValidationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMValidation>
      _instance;
} _TMValidation_default_instance_;
class TMGetPeersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMGetPeers>
      _instance;
} _TMGetPeers_default_instance_;
class TMIPv4EndpointDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMIPv4Endpoint>
      _instance;
} _TMIPv4Endpoint_default_instance_;
class TMPeersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMPeers>
      _instance;
} _TMPeers_default_instance_;
class TMEndpointDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMEndpoint>
      _instance;
} _TMEndpoint_default_instance_;
class TMEndpointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMEndpoints>
      _instance;
} _TMEndpoints_default_instance_;
class TMIndexedObjectDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMIndexedObject>
      _instance;
} _TMIndexedObject_default_instance_;
class TMGetObjectByHashDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMGetObjectByHash>
      _instance;
} _TMGetObjectByHash_default_instance_;
class TMLedgerNodeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMLedgerNode>
      _instance;
} _TMLedgerNode_default_instance_;
class TMGetLedgerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMGetLedger>
      _instance;
} _TMGetLedger_default_instance_;
class TMLedgerDataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMLedgerData>
      _instance;
} _TMLedgerData_default_instance_;
class TMPingDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TMPing>
      _instance;
} _TMPing_default_instance_;
}  // namespace protocol
namespace protobuf_ripple_2eproto {
void InitDefaultsTMManifestImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMManifest_default_instance_;
    new (ptr) ::protocol::TMManifest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifest::InitAsDefaultInstance();
}

void InitDefaultsTMManifest() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMManifestImpl);
}

void InitDefaultsTMManifestsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMManifest();
  {
    void* ptr = &::protocol::_TMManifests_default_instance_;
    new (ptr) ::protocol::TMManifests();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifests::InitAsDefaultInstance();
}

void InitDefaultsTMManifests() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMManifestsImpl);
}

void InitDefaultsTMProofWorkImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMProofWork_default_instance_;
    new (ptr) ::protocol::TMProofWork();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProofWork::InitAsDefaultInstance();
}

void InitDefaultsTMProofWork() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMProofWorkImpl);
}

void InitDefaultsTMHelloImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMProofWork();
  {
    void* ptr = &::protocol::_TMHello_default_instance_;
    new (ptr) ::protocol::TMHello();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHello::InitAsDefaultInstance();
}

void InitDefaultsTMHello() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMHelloImpl);
}

void InitDefaultsTMClusterNodeImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMClusterNode_default_instance_;
    new (ptr) ::protocol::TMClusterNode();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMClusterNode::InitAsDefaultInstance();
}

void InitDefaultsTMClusterNode() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMClusterNodeImpl);
}

void InitDefaultsTMLoadSourceImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMLoadSource_default_instance_;
    new (ptr) ::protocol::TMLoadSource();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLoadSource::InitAsDefaultInstance();
}

void InitDefaultsTMLoadSource() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMLoadSourceImpl);
}

void InitDefaultsTMClusterImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMClusterNode();
  protobuf_ripple_2eproto::InitDefaultsTMLoadSource();
  {
    void* ptr = &::protocol::_TMCluster_default_instance_;
    new (ptr) ::protocol::TMCluster();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMCluster::InitAsDefaultInstance();
}

void InitDefaultsTMCluster() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMClusterImpl);
}

void InitDefaultsTMTransactionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMTransaction_default_instance_;
    new (ptr) ::protocol::TMTransaction();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMTransaction::InitAsDefaultInstance();
}

void InitDefaultsTMTransaction() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMTransactionImpl);
}

void InitDefaultsTMStatusChangeImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMStatusChange_default_instance_;
    new (ptr) ::protocol::TMStatusChange();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMStatusChange::InitAsDefaultInstance();
}

void InitDefaultsTMStatusChange() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMStatusChangeImpl);
}

void InitDefaultsTMProposeSetImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMProposeSet_default_instance_;
    new (ptr) ::protocol::TMProposeSet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProposeSet::InitAsDefaultInstance();
}

void InitDefaultsTMProposeSet() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMProposeSetImpl);
}

void InitDefaultsTMHaveTransactionSetImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMHaveTransactionSet_default_instance_;
    new (ptr) ::protocol::TMHaveTransactionSet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHaveTransactionSet::InitAsDefaultInstance();
}

void InitDefaultsTMHaveTransactionSet() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMHaveTransactionSetImpl);
}

void InitDefaultsTMValidationImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMValidation_default_instance_;
    new (ptr) ::protocol::TMValidation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidation::InitAsDefaultInstance();
}

void InitDefaultsTMValidation() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMValidationImpl);
}

void InitDefaultsTMGetPeersImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMGetPeers_default_instance_;
    new (ptr) ::protocol::TMGetPeers();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetPeers::InitAsDefaultInstance();
}

void InitDefaultsTMGetPeers() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMGetPeersImpl);
}

void InitDefaultsTMIPv4EndpointImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMIPv4Endpoint_default_instance_;
    new (ptr) ::protocol::TMIPv4Endpoint();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIPv4Endpoint::InitAsDefaultInstance();
}

void InitDefaultsTMIPv4Endpoint() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMIPv4EndpointImpl);
}

void InitDefaultsTMPeersImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMIPv4Endpoint();
  {
    void* ptr = &::protocol::_TMPeers_default_instance_;
    new (ptr) ::protocol::TMPeers();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeers::InitAsDefaultInstance();
}

void InitDefaultsTMPeers() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMPeersImpl);
}

void InitDefaultsTMEndpointImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMIPv4Endpoint();
  {
    void* ptr = &::protocol::_TMEndpoint_default_instance_;
    new (ptr) ::protocol::TMEndpoint();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoint::InitAsDefaultInstance();
}

void InitDefaultsTMEndpoint() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMEndpointImpl);
}

void InitDefaultsTMEndpointsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMEndpoint();
  {
    void* ptr = &::protocol::_TMEndpoints_default_instance_;
    new (ptr) ::protocol::TMEndpoints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints::InitAsDefaultInstance();
}

void InitDefaultsTMEndpoints() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMEndpointsImpl);
}

void InitDefaultsTMIndexedObjectImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMIndexedObject_default_instance_;
    new (ptr) ::protocol::TMIndexedObject();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIndexedObject::InitAsDefaultInstance();
}

void InitDefaultsTMIndexedObject() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMIndexedObjectImpl);
}

void InitDefaultsTMGetObjectByHashImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMIndexedObject();
  {
    void* ptr = &::protocol::_TMGetObjectByHash_default_instance_;
    new (ptr) ::protocol::TMGetObjectByHash();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetObjectByHash::InitAsDefaultInstance();
}

void InitDefaultsTMGetObjectByHash() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMGetObjectByHashImpl);
}

void InitDefaultsTMLedgerNodeImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMLedgerNode_default_instance_;
    new (ptr) ::protocol::TMLedgerNode();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerNode::InitAsDefaultInstance();
}

void InitDefaultsTMLedgerNode() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMLedgerNodeImpl);
}

void InitDefaultsTMGetLedgerImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMGetLedger_default_instance_;
    new (ptr) ::protocol::TMGetLedger();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetLedger::InitAsDefaultInstance();
}

void InitDefaultsTMGetLedger() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMGetLedgerImpl);
}

void InitDefaultsTMLedgerDataImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_ripple_2eproto::InitDefaultsTMLedgerNode();
  {
    void* ptr = &::protocol::_TMLedgerData_default_instance_;
    new (ptr) ::protocol::TMLedgerData();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerData::InitAsDefaultInstance();
}

void InitDefaultsTMLedgerData() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMLedgerDataImpl);
}

void InitDefaultsTMPingImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::protocol::_TMPing_default_instance_;
    new (ptr) ::protocol::TMPing();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPing::InitAsDefaultInstance();
}

void InitDefaultsTMPing() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTMPingImpl);
}

::google::protobuf::Metadata file_level_metadata[23];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[12];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifest, stobject_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifests, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifests, list_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMManifests, history_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, token_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, iterations_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, target_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, challenge_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, response_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProofWork, result_),
  0,
  4,
  1,
  2,
  3,
  5,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, protoversion_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, protoversionmin_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, nodepublic_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, nodeproof_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, fullversion_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, nettime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, ipv4port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, ledgerindex_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, ledgerclosed_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, ledgerprevious_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, nodeprivate_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, proofofwork_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, testnet_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, local_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHello, remote_ip_),
  6,
  7,
  0,
  1,
  2,
  8,
  9,
  10,
  3,
  4,
  11,
  5,
  12,
  13,
  14,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, publickey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, reporttime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, nodeload_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, nodename_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMClusterNode, address_),
  0,
  3,
  4,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLoadSource, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLoadSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLoadSource, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLoadSource, cost_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLoadSource, count_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMCluster, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMCluster, clusternodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMCluster, loadsources_),
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, rawtransaction_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, receivetimestamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMTransaction, deferred_),
  0,
  3,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, newstatus_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, newevent_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, ledgerseq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhashprevious_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, networktime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, firstseq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMStatusChange, lastseq_),
  6,
  7,
  2,
  0,
  1,
  4,
  3,
  5,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, proposeseq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, currenttxhash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, nodepubkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, closetime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, signature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, previousledger_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, checkedsignature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, addedtransactions_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, removedtransactions_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMProposeSet, hops_),
  4,
  0,
  1,
  5,
  2,
  3,
  6,
  ~0u,
  ~0u,
  7,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHaveTransactionSet, status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMHaveTransactionSet, hash_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMValidation, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMValidation, validation_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMValidation, checkedsignature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMValidation, hops_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetPeers, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetPeers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetPeers, doweneedthis_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIPv4Endpoint, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIPv4Endpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIPv4Endpoint, ipv4_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIPv4Endpoint, ipv4port_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPeers, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPeers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPeers, nodes_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoint, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoint, ipv4_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoint, hops_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoints, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoints, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMEndpoints, endpoints_),
  0,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, hash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, nodeid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, index_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, data_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMIndexedObject, ledgerseq_),
  0,
  1,
  2,
  3,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, query_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, seq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, ledgerhash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, fat_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetObjectByHash, objects_),
  1,
  3,
  2,
  0,
  4,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerNode, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerNode, nodedata_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerNode, nodeid_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, itype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, ltype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, ledgerhash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, ledgerseq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, nodeids_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, requestcookie_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, querytype_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMGetLedger, querydepth_),
  1,
  2,
  0,
  3,
  ~0u,
  5,
  4,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, ledgerhash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, ledgerseq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, requestcookie_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMLedgerData, error_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, seq_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, pingtime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::protocol::TMPing, nettime_),
  0,
  1,
  2,
  3,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::protocol::TMManifest)},
  { 7, 14, sizeof(::protocol::TMManifests)},
  { 16, 27, sizeof(::protocol::TMProofWork)},
  { 33, 53, sizeof(::protocol::TMHello)},
  { 68, 78, sizeof(::protocol::TMClusterNode)},
  { 83, 91, sizeof(::protocol::TMLoadSource)},
  { 94, 101, sizeof(::protocol::TMCluster)},
  { 103, 112, sizeof(::protocol::TMTransaction)},
  { 116, 129, sizeof(::protocol::TMStatusChange)},
  { 137, 152, sizeof(::protocol::TMProposeSet)},
  { 162, 169, sizeof(::protocol::TMHaveTransactionSet)},
  { 171, 179, sizeof(::protocol::TMValidation)},
  { 182, 188, sizeof(::protocol::TMGetPeers)},
  { 189, 196, sizeof(::protocol::TMIPv4Endpoint)},
  { 198, 204, sizeof(::protocol::TMPeers)},
  { 205, 212, sizeof(::protocol::TMEndpoint)},
  { 214, 221, sizeof(::protocol::TMEndpoints)},
  { 223, 233, sizeof(::protocol::TMIndexedObject)},
  { 238, 249, sizeof(::protocol::TMGetObjectByHash)},
  { 255, 262, sizeof(::protocol::TMLedgerNode)},
  { 264, 277, sizeof(::protocol::TMGetLedger)},
  { 285, 296, sizeof(::protocol::TMLedgerData)},
  { 302, 311, sizeof(::protocol::TMPing)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMManifest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMManifests_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMProofWork_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMHello_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMClusterNode_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMLoadSource_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMCluster_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMTransaction_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMStatusChange_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMProposeSet_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMHaveTransactionSet_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMValidation_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMGetPeers_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMIPv4Endpoint_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMPeers_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMEndpoint_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMEndpoints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMIndexedObject_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMGetObjectByHash_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMLedgerNode_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMGetLedger_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMLedgerData_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::protocol::_TMPing_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "ripple.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 23);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\014ripple.proto\022\010protocol\"\036\n\nTMManifest\022\020"
      "\n\010stobject\030\001 \002(\014\"F\n\013TMManifests\022\"\n\004list\030"
      "\001 \003(\0132\024.protocol.TMManifest\022\023\n\007history\030\002"
      " \001(\010B\002\030\001\"\206\002\n\013TMProofWork\022\r\n\005token\030\001 \002(\t\022"
      "\022\n\niterations\030\002 \001(\r\022\016\n\006target\030\003 \001(\014\022\021\n\tc"
      "hallenge\030\004 \001(\014\022\020\n\010response\030\005 \001(\014\022/\n\006resu"
      "lt\030\006 \001(\0162\037.protocol.TMProofWork.PowResul"
      "t\"n\n\tPowResult\022\n\n\006powrOK\020\000\022\016\n\npowrREUSED"
      "\020\001\022\017\n\013powrEXPIRED\020\002\022\017\n\013powrTOOEASY\020\003\022\017\n\013"
      "powrINVALID\020\004\022\022\n\016powrDISCONNECT\020\005\"\321\002\n\007TM"
      "Hello\022\024\n\014protoVersion\030\001 \002(\r\022\027\n\017protoVers"
      "ionMin\030\002 \002(\r\022\022\n\nnodePublic\030\003 \002(\014\022\021\n\tnode"
      "Proof\030\004 \002(\014\022\023\n\013fullVersion\030\005 \001(\t\022\017\n\007netT"
      "ime\030\006 \001(\004\022\020\n\010ipv4Port\030\007 \001(\r\022\023\n\013ledgerInd"
      "ex\030\010 \001(\r\022\024\n\014ledgerClosed\030\t \001(\014\022\026\n\016ledger"
      "Previous\030\n \001(\014\022\023\n\013nodePrivate\030\013 \001(\010\022*\n\013p"
      "roofOfWork\030\014 \001(\0132\025.protocol.TMProofWork\022"
      "\017\n\007testNet\030\r \001(\010\022\020\n\010local_ip\030\016 \001(\r\022\021\n\tre"
      "mote_ip\030\017 \001(\r\"k\n\rTMClusterNode\022\021\n\tpublic"
      "Key\030\001 \002(\t\022\022\n\nreportTime\030\002 \002(\r\022\020\n\010nodeLoa"
      "d\030\003 \002(\r\022\020\n\010nodeName\030\004 \001(\t\022\017\n\007address\030\005 \001"
      "(\t\"9\n\014TMLoadSource\022\014\n\004name\030\001 \002(\t\022\014\n\004cost"
      "\030\002 \002(\r\022\r\n\005count\030\003 \001(\r\"g\n\tTMCluster\022-\n\014cl"
      "usterNodes\030\001 \003(\0132\027.protocol.TMClusterNod"
      "e\022+\n\013loadSources\030\002 \003(\0132\026.protocol.TMLoad"
      "Source\"\200\001\n\rTMTransaction\022\026\n\016rawTransacti"
      "on\030\001 \002(\014\022+\n\006status\030\002 \002(\0162\033.protocol.Tran"
      "sactionStatus\022\030\n\020receiveTimestamp\030\003 \001(\004\022"
      "\020\n\010deferred\030\004 \001(\010\"\333\001\n\016TMStatusChange\022\'\n\t"
      "newStatus\030\001 \001(\0162\024.protocol.NodeStatus\022%\n"
      "\010newEvent\030\002 \001(\0162\023.protocol.NodeEvent\022\021\n\t"
      "ledgerSeq\030\003 \001(\r\022\022\n\nledgerHash\030\004 \001(\014\022\032\n\022l"
      "edgerHashPrevious\030\005 \001(\014\022\023\n\013networkTime\030\006"
      " \001(\004\022\020\n\010firstSeq\030\007 \001(\r\022\017\n\007lastSeq\030\010 \001(\r\""
      "\353\001\n\014TMProposeSet\022\022\n\nproposeSeq\030\001 \002(\r\022\025\n\r"
      "currentTxHash\030\002 \002(\014\022\022\n\nnodePubKey\030\003 \002(\014\022"
      "\021\n\tcloseTime\030\004 \002(\r\022\021\n\tsignature\030\005 \002(\014\022\026\n"
      "\016previousledger\030\006 \002(\014\022\030\n\020checkedSignatur"
      "e\030\007 \001(\010\022\031\n\021addedTransactions\030\n \003(\014\022\033\n\023re"
      "movedTransactions\030\013 \003(\014\022\014\n\004hops\030\014 \001(\r\"K\n"
      "\024TMHaveTransactionSet\022%\n\006status\030\001 \002(\0162\025."
      "protocol.TxSetStatus\022\014\n\004hash\030\002 \002(\014\"J\n\014TM"
      "Validation\022\022\n\nvalidation\030\001 \002(\014\022\030\n\020checke"
      "dSignature\030\002 \001(\010\022\014\n\004hops\030\003 \001(\r\"\"\n\nTMGetP"
      "eers\022\024\n\014doWeNeedThis\030\001 \002(\r\"0\n\016TMIPv4Endp"
      "oint\022\014\n\004ipv4\030\001 \002(\r\022\020\n\010ipv4Port\030\002 \002(\r\"2\n\007"
      "TMPeers\022\'\n\005nodes\030\001 \003(\0132\030.protocol.TMIPv4"
      "Endpoint\"B\n\nTMEndpoint\022&\n\004ipv4\030\001 \002(\0132\030.p"
      "rotocol.TMIPv4Endpoint\022\014\n\004hops\030\002 \002(\r\"G\n\013"
      "TMEndpoints\022\017\n\007version\030\001 \002(\r\022\'\n\tendpoint"
      "s\030\002 \003(\0132\024.protocol.TMEndpoint\"_\n\017TMIndex"
      "edObject\022\014\n\004hash\030\001 \001(\014\022\016\n\006nodeID\030\002 \001(\014\022\r"
      "\n\005index\030\003 \001(\014\022\014\n\004data\030\004 \001(\014\022\021\n\tledgerSeq"
      "\030\005 \001(\r\"\277\002\n\021TMGetObjectByHash\0224\n\004type\030\001 \002"
      "(\0162&.protocol.TMGetObjectByHash.ObjectTy"
      "pe\022\r\n\005query\030\002 \002(\010\022\013\n\003seq\030\003 \001(\r\022\022\n\nledger"
      "Hash\030\004 \001(\014\022\013\n\003fat\030\005 \001(\010\022*\n\007objects\030\006 \003(\013"
      "2\031.protocol.TMIndexedObject\"\212\001\n\nObjectTy"
      "pe\022\r\n\totUNKNOWN\020\000\022\014\n\010otLEDGER\020\001\022\021\n\rotTRA"
      "NSACTION\020\002\022\026\n\022otTRANSACTION_NODE\020\003\022\020\n\014ot"
      "STATE_NODE\020\004\022\020\n\014otCAS_OBJECT\020\005\022\020\n\014otFETC"
      "H_PACK\020\006\"0\n\014TMLedgerNode\022\020\n\010nodedata\030\001 \002"
      "(\014\022\016\n\006nodeid\030\002 \001(\014\"\354\001\n\013TMGetLedger\022)\n\005it"
      "ype\030\001 \002(\0162\032.protocol.TMLedgerInfoType\022%\n"
      "\005ltype\030\002 \001(\0162\026.protocol.TMLedgerType\022\022\n\n"
      "ledgerHash\030\003 \001(\014\022\021\n\tledgerSeq\030\004 \001(\r\022\017\n\007n"
      "odeIDs\030\005 \003(\014\022\025\n\rrequestCookie\030\006 \001(\004\022(\n\tq"
      "ueryType\030\007 \001(\0162\025.protocol.TMQueryType\022\022\n"
      "\nqueryDepth\030\010 \001(\r\"\304\001\n\014TMLedgerData\022\022\n\nle"
      "dgerHash\030\001 \002(\014\022\021\n\tledgerSeq\030\002 \002(\r\022(\n\004typ"
      "e\030\003 \002(\0162\032.protocol.TMLedgerInfoType\022%\n\005n"
      "odes\030\004 \003(\0132\026.protocol.TMLedgerNode\022\025\n\rre"
      "questCookie\030\005 \001(\r\022%\n\005error\030\006 \001(\0162\026.proto"
      "col.TMReplyError\"\205\001\n\006TMPing\022\'\n\004type\030\001 \002("
      "\0162\031.protocol.TMPing.pingType\022\013\n\003seq\030\002 \001("
      "\r\022\020\n\010pingTime\030\003 \001(\004\022\017\n\007netTime\030\004 \001(\004\"\"\n\010"
      "pingType\022\n\n\006ptPING\020\000\022\n\n\006ptPONG\020\001*\240\002\n\013Mes"
      "sageType\022\013\n\007mtHELLO\020\001\022\017\n\013mtMANIFESTS\020\002\022\n"
      "\n\006mtPING\020\003\022\021\n\rmtPROOFOFWORK\020\004\022\r\n\tmtCLUST"
      "ER\020\005\022\017\n\013mtGET_PEERS\020\014\022\013\n\007mtPEERS\020\r\022\017\n\013mt"
      "ENDPOINTS\020\017\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mtGET_"
      "LEDGER\020\037\022\021\n\rmtLEDGER_DATA\020 \022\024\n\020mtPROPOSE"
      "_LEDGER\020!\022\023\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmtHAVE"
      "_SET\020#\022\020\n\014mtVALIDATION\020)\022\021\n\rmtGET_OBJECT"
      "S\020**\241\001\n\021TransactionStatus\022\t\n\005tsNEW\020\001\022\r\n\t"
      "tsCURRENT\020\002\022\016\n\ntsCOMMITED\020\003\022\025\n\021tsREJECT_"
      "CONFLICT\020\004\022\024\n\020tsREJECT_INVALID\020\005\022\022\n\016tsRE"
      "JECT_FUNDS\020\006\022\016\n\ntsHELD_SEQ\020\007\022\021\n\rtsHELD_L"
      "EDGER\020\010*c\n\nNodeStatus\022\020\n\014nsCONNECTING\020\001\022"
      "\017\n\013nsCONNECTED\020\002\022\020\n\014nsMONITORING\020\003\022\020\n\014ns"
      "VALIDATING\020\004\022\016\n\nnsSHUTTING\020\005*`\n\tNodeEven"
      "t\022\024\n\020neCLOSING_LEDGER\020\001\022\025\n\021neACCEPTED_LE"
      "DGER\020\002\022\025\n\021neSWITCHED_LEDGER\020\003\022\017\n\013neLOST_"
      "SYNC\020\004*4\n\013TxSetStatus\022\n\n\006tsHAVE\020\001\022\r\n\ttsC"
      "AN_GET\020\002\022\n\n\006tsNEED\020\003*P\n\020TMLedgerInfoType"
      "\022\n\n\006liBASE\020\000\022\r\n\tliTX_NODE\020\001\022\r\n\tliAS_NODE"
      "\020\002\022\022\n\016liTS_CANDIDATE\020\003*;\n\014TMLedgerType\022\016"
      "\n\nltACCEPTED\020\000\022\r\n\tltCURRENT\020\001\022\014\n\010ltCLOSE"
      "D\020\002*\035\n\013TMQueryType\022\016\n\nqtINDIRECT\020\000*.\n\014TM"
      "ReplyError\022\017\n\013reNO_LEDGER\020\001\022\r\n\treNO_NODE"
      "\020\002"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 4002);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ripple.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_ripple_2eproto
namespace protocol {
const ::google::protobuf::EnumDescriptor* TMProofWork_PowResult_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[0];
}
bool TMProofWork_PowResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TMProofWork_PowResult TMProofWork::powrOK;
const TMProofWork_PowResult TMProofWork::powrREUSED;
const TMProofWork_PowResult TMProofWork::powrEXPIRED;
const TMProofWork_PowResult TMProofWork::powrTOOEASY;
const TMProofWork_PowResult TMProofWork::powrINVALID;
const TMProofWork_PowResult TMProofWork::powrDISCONNECT;
const TMProofWork_PowResult TMProofWork::PowResult_MIN;
const TMProofWork_PowResult TMProofWork::PowResult_MAX;
const int TMProofWork::PowResult_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[1];
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
const TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
const int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TMPing_pingType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[2];
}
bool TMPing_pingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TMPing_pingType TMPing::ptPING;
const TMPing_pingType TMPing::ptPONG;
const TMPing_pingType TMPing::pingType_MIN;
const TMPing_pingType TMPing::pingType_MAX;
const int TMPing::pingType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[3];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 12:
    case 13:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TransactionStatus_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[4];
}
bool TransactionStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NodeStatus_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[5];
}
bool NodeStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NodeEvent_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[6];
}
bool NodeEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TxSetStatus_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[7];
}
bool TxSetStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMLedgerInfoType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[8];
}
bool TMLedgerInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMLedgerType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[9];
}
bool TMLedgerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMQueryType_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[10];
}
bool TMQueryType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TMReplyError_descriptor() {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_ripple_2eproto::file_level_enum_descriptors[11];
}
bool TMReplyError_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TMManifest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMManifest::kStobjectFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMManifest::TMManifest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMManifest();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMManifest)
}
TMManifest::TMManifest(const TMManifest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  stobject_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_stobject()) {
    stobject_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.stobject_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifest)
}

void TMManifest::SharedCtor() {
  _cached_size_ = 0;
  stobject_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

TMManifest::~TMManifest() {
  // @@protoc_insertion_point(destructor:protocol.TMManifest)
  SharedDtor();
}

void TMManifest::SharedDtor() {
  stobject_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMManifest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMManifest::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMManifest& TMManifest::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMManifest();
  return *internal_default_instance();
}

TMManifest* TMManifest::New(::google::protobuf::Arena* arena) const {
  TMManifest* n = new TMManifest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!stobject_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*stobject_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMManifest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMManifest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes stobject = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_stobject()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMManifest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMManifest)
  return false;
#undef DO_
}

void TMManifest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMManifest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->stobject(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMManifest)
}

::google::protobuf::uint8* TMManifest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->stobject(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifest)
  return target;
}

size_t TMManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes stobject = 1;
  if (has_stobject()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->stobject());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMManifest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMManifest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifest)
    MergeFrom(*source);
  }
}

void TMManifest::MergeFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_stobject()) {
    set_has_stobject();
    stobject_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.stobject_);
  }
}

void TMManifest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifest::CopyFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMManifest::Swap(TMManifest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMManifest::InternalSwap(TMManifest* other) {
  using std::swap;
  stobject_.Swap(&other->stobject_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMManifest::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMManifests::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMManifests::kListFieldNumber;
const int TMManifests::kHistoryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMManifests::TMManifests()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMManifests();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMManifests)
}
TMManifests::TMManifests(const TMManifests& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      list_(from.list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  history_ = from.history_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifests)
}

void TMManifests::SharedCtor() {
  _cached_size_ = 0;
  history_ = false;
}

TMManifests::~TMManifests() {
  // @@protoc_insertion_point(destructor:protocol.TMManifests)
  SharedDtor();
}

void TMManifests::SharedDtor() {
}

void TMManifests::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMManifests::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMManifests& TMManifests::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMManifests();
  return *internal_default_instance();
}

TMManifests* TMManifests::New(::google::protobuf::Arena* arena) const {
  TMManifests* n = new TMManifests;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMManifests::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifests)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_.Clear();
  history_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMManifests::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMManifests)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMManifest list = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool history = 2 [deprecated = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_history();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &history_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMManifests)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMManifests)
  return false;
#undef DO_
}

void TMManifests::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMManifests)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(static_cast<int>(i)), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->history(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMManifests)
}

::google::protobuf::uint8* TMManifests::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifests)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->list_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->list(static_cast<int>(i)), deterministic, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->history(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifests)
  return target;
}

size_t TMManifests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifests)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .protocol.TMManifest list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->list(static_cast<int>(i)));
    }
  }

  // optional bool history = 2 [deprecated = true];
  if (has_history()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMManifests::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifests* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMManifests>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifests)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifests)
    MergeFrom(*source);
  }
}

void TMManifests::MergeFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_.MergeFrom(from.list_);
  if (from.has_history()) {
    set_history(from.history());
  }
}

void TMManifests::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifests::CopyFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifests::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->list())) return false;
  return true;
}

void TMManifests::Swap(TMManifests* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMManifests::InternalSwap(TMManifests* other) {
  using std::swap;
  list_.InternalSwap(&other->list_);
  swap(history_, other->history_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMManifests::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMProofWork::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMProofWork::kTokenFieldNumber;
const int TMProofWork::kIterationsFieldNumber;
const int TMProofWork::kTargetFieldNumber;
const int TMProofWork::kChallengeFieldNumber;
const int TMProofWork::kResponseFieldNumber;
const int TMProofWork::kResultFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMProofWork::TMProofWork()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMProofWork();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMProofWork)
}
TMProofWork::TMProofWork(const TMProofWork& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_token()) {
    token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
  }
  target_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_target()) {
    target_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.target_);
  }
  challenge_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_challenge()) {
    challenge_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_);
  }
  response_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_response()) {
    response_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.response_);
  }
  ::memcpy(&iterations_, &from.iterations_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_) -
    reinterpret_cast<char*>(&iterations_)) + sizeof(result_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofWork)
}

void TMProofWork::SharedCtor() {
  _cached_size_ = 0;
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  target_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  challenge_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  response_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&iterations_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_) -
      reinterpret_cast<char*>(&iterations_)) + sizeof(result_));
}

TMProofWork::~TMProofWork() {
  // @@protoc_insertion_point(destructor:protocol.TMProofWork)
  SharedDtor();
}

void TMProofWork::SharedDtor() {
  token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  target_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  challenge_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  response_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMProofWork::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMProofWork::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMProofWork& TMProofWork::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMProofWork();
  return *internal_default_instance();
}

TMProofWork* TMProofWork::New(::google::protobuf::Arena* arena) const {
  TMProofWork* n = new TMProofWork;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMProofWork::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!token_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*token_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!target_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*target_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!challenge_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*challenge_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!response_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*response_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 48u) {
    ::memset(&iterations_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_) -
        reinterpret_cast<char*>(&iterations_)) + sizeof(result_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMProofWork::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMProofWork)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->token().data(), static_cast<int>(this->token().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMProofWork.token");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 iterations = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_iterations();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &iterations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes target = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_target()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes challenge = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_challenge()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes response = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_response()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMProofWork.PowResult result = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMProofWork_PowResult_IsValid(value)) {
            set_result(static_cast< ::protocol::TMProofWork_PowResult >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMProofWork)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMProofWork)
  return false;
#undef DO_
}

void TMProofWork::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMProofWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->token().data(), static_cast<int>(this->token().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMProofWork.token");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->token(), output);
  }

  // optional uint32 iterations = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->iterations(), output);
  }

  // optional bytes target = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->target(), output);
  }

  // optional bytes challenge = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->challenge(), output);
  }

  // optional bytes response = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->response(), output);
  }

  // optional .protocol.TMProofWork.PowResult result = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->result(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMProofWork)
}

::google::protobuf::uint8* TMProofWork::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofWork)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->token().data(), static_cast<int>(this->token().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMProofWork.token");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->token(), target);
  }

  // optional uint32 iterations = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->iterations(), target);
  }

  // optional bytes target = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->target(), target);
  }

  // optional bytes challenge = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->challenge(), target);
  }

  // optional bytes response = 5;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->response(), target);
  }

  // optional .protocol.TMProofWork.PowResult result = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->result(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofWork)
  return target;
}

size_t TMProofWork::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofWork)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required string token = 1;
  if (has_token()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->token());
  }
  if (_has_bits_[0 / 32] & 62u) {
    // optional bytes target = 3;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->target());
    }

    // optional bytes challenge = 4;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->challenge());
    }

    // optional bytes response = 5;
    if (has_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->response());
    }

    // optional uint32 iterations = 2;
    if (has_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->iterations());
    }

    // optional .protocol.TMProofWork.PowResult result = 6;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMProofWork::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProofWork)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProofWork* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMProofWork>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProofWork)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProofWork)
    MergeFrom(*source);
  }
}

void TMProofWork::MergeFrom(const TMProofWork& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofWork)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_token();
      token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_target();
      target_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.target_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_challenge();
      challenge_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_response();
      response_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.response_);
    }
    if (cached_has_bits & 0x00000010u) {
      iterations_ = from.iterations_;
    }
    if (cached_has_bits & 0x00000020u) {
      result_ = from.result_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProofWork::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProofWork)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofWork::CopyFrom(const TMProofWork& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofWork)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofWork::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMProofWork::Swap(TMProofWork* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMProofWork::InternalSwap(TMProofWork* other) {
  using std::swap;
  token_.Swap(&other->token_);
  target_.Swap(&other->target_);
  challenge_.Swap(&other->challenge_);
  response_.Swap(&other->response_);
  swap(iterations_, other->iterations_);
  swap(result_, other->result_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMProofWork::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMHello::InitAsDefaultInstance() {
  ::protocol::_TMHello_default_instance_._instance.get_mutable()->proofofwork_ = const_cast< ::protocol::TMProofWork*>(
      ::protocol::TMProofWork::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMHello::kProtoVersionFieldNumber;
const int TMHello::kProtoVersionMinFieldNumber;
const int TMHello::kNodePublicFieldNumber;
const int TMHello::kNodeProofFieldNumber;
const int TMHello::kFullVersionFieldNumber;
const int TMHello::kNetTimeFieldNumber;
const int TMHello::kIpv4PortFieldNumber;
const int TMHello::kLedgerIndexFieldNumber;
const int TMHello::kLedgerClosedFieldNumber;
const int TMHello::kLedgerPreviousFieldNumber;
const int TMHello::kNodePrivateFieldNumber;
const int TMHello::kProofOfWorkFieldNumber;
const int TMHello::kTestNetFieldNumber;
const int TMHello::kLocalIpFieldNumber;
const int TMHello::kRemoteIpFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMHello::TMHello()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMHello();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMHello)
}
TMHello::TMHello(const TMHello& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nodepublic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepublic()) {
    nodepublic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepublic_);
  }
  nodeproof_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodeproof()) {
    nodeproof_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeproof_);
  }
  fullversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_fullversion()) {
    fullversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fullversion_);
  }
  ledgerclosed_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerclosed()) {
    ledgerclosed_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerclosed_);
  }
  ledgerprevious_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerprevious()) {
    ledgerprevious_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerprevious_);
  }
  if (from.has_proofofwork()) {
    proofofwork_ = new ::protocol::TMProofWork(*from.proofofwork_);
  } else {
    proofofwork_ = NULL;
  }
  ::memcpy(&protoversion_, &from.protoversion_,
    static_cast<size_t>(reinterpret_cast<char*>(&remote_ip_) -
    reinterpret_cast<char*>(&protoversion_)) + sizeof(remote_ip_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMHello)
}

void TMHello::SharedCtor() {
  _cached_size_ = 0;
  nodepublic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeproof_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fullversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerclosed_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerprevious_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&proofofwork_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&remote_ip_) -
      reinterpret_cast<char*>(&proofofwork_)) + sizeof(remote_ip_));
}

TMHello::~TMHello() {
  // @@protoc_insertion_point(destructor:protocol.TMHello)
  SharedDtor();
}

void TMHello::SharedDtor() {
  nodepublic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeproof_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fullversion_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerclosed_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerprevious_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete proofofwork_;
}

void TMHello::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMHello::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMHello& TMHello::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMHello();
  return *internal_default_instance();
}

TMHello* TMHello::New(::google::protobuf::Arena* arena) const {
  TMHello* n = new TMHello;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMHello::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHello)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!nodepublic_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodepublic_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!nodeproof_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodeproof_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!fullversion_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*fullversion_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!ledgerclosed_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ledgerclosed_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(!ledgerprevious_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ledgerprevious_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(proofofwork_ != NULL);
      proofofwork_->Clear();
    }
  }
  if (cached_has_bits & 192u) {
    ::memset(&protoversion_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&protoversionmin_) -
        reinterpret_cast<char*>(&protoversion_)) + sizeof(protoversionmin_));
  }
  if (cached_has_bits & 32512u) {
    ::memset(&nettime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&remote_ip_) -
        reinterpret_cast<char*>(&nettime_)) + sizeof(remote_ip_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMHello::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMHello)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 protoVersion = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_protoversion();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protoversion_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 protoVersionMin = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_protoversionmin();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protoversionmin_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes nodePublic = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepublic()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes nodeProof = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeproof()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string fullVersion = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fullversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->fullversion().data(), static_cast<int>(this->fullversion().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMHello.fullVersion");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 netTime = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_nettime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nettime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ipv4Port = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_ipv4port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerIndex = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_ledgerindex();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerClosed = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerclosed()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerPrevious = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerprevious()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool nodePrivate = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_nodeprivate();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nodeprivate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMProofWork proofOfWork = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_proofofwork()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool testNet = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          set_has_testnet();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &testnet_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 local_ip = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          set_has_local_ip();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &local_ip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 remote_ip = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {
          set_has_remote_ip();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remote_ip_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMHello)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMHello)
  return false;
#undef DO_
}

void TMHello::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMHello)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 protoVersion = 1;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->protoversion(), output);
  }

  // required uint32 protoVersionMin = 2;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->protoversionmin(), output);
  }

  // required bytes nodePublic = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nodepublic(), output);
  }

  // required bytes nodeProof = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->nodeproof(), output);
  }

  // optional string fullVersion = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fullversion().data(), static_cast<int>(this->fullversion().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMHello.fullVersion");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->fullversion(), output);
  }

  // optional uint64 netTime = 6;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->nettime(), output);
  }

  // optional uint32 ipv4Port = 7;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->ipv4port(), output);
  }

  // optional uint32 ledgerIndex = 8;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->ledgerindex(), output);
  }

  // optional bytes ledgerClosed = 9;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      9, this->ledgerclosed(), output);
  }

  // optional bytes ledgerPrevious = 10;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->ledgerprevious(), output);
  }

  // optional bool nodePrivate = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->nodeprivate(), output);
  }

  // optional .protocol.TMProofWork proofOfWork = 12;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->proofofwork_, output);
  }

  // optional bool testNet = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->testnet(), output);
  }

  // optional uint32 local_ip = 14;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->local_ip(), output);
  }

  // optional uint32 remote_ip = 15;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->remote_ip(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMHello)
}

::google::protobuf::uint8* TMHello::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHello)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 protoVersion = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->protoversion(), target);
  }

  // required uint32 protoVersionMin = 2;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->protoversionmin(), target);
  }

  // required bytes nodePublic = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nodepublic(), target);
  }

  // required bytes nodeProof = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->nodeproof(), target);
  }

  // optional string fullVersion = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fullversion().data(), static_cast<int>(this->fullversion().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMHello.fullVersion");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->fullversion(), target);
  }

  // optional uint64 netTime = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->nettime(), target);
  }

  // optional uint32 ipv4Port = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->ipv4port(), target);
  }

  // optional uint32 ledgerIndex = 8;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->ledgerindex(), target);
  }

  // optional bytes ledgerClosed = 9;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->ledgerclosed(), target);
  }

  // optional bytes ledgerPrevious = 10;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->ledgerprevious(), target);
  }

  // optional bool nodePrivate = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->nodeprivate(), target);
  }

  // optional .protocol.TMProofWork proofOfWork = 12;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, *this->proofofwork_, deterministic, target);
  }

  // optional bool testNet = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->testnet(), target);
  }

  // optional uint32 local_ip = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->local_ip(), target);
  }

  // optional uint32 remote_ip = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->remote_ip(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHello)
  return target;
}

size_t TMHello::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHello)
  size_t total_size = 0;

  if (has_nodepublic()) {
    // required bytes nodePublic = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodepublic());
  }

  if (has_nodeproof()) {
    // required bytes nodeProof = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodeproof());
  }

  if (has_protoversion()) {
    // required uint32 protoVersion = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->protoversion());
  }

  if (has_protoversionmin()) {
    // required uint32 protoVersionMin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->protoversionmin());
  }

  return total_size;
}
size_t TMHello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHello)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x000000c3) ^ 0x000000c3) == 0) {  // All required fields are present.
    // required bytes nodePublic = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodepublic());

    // required bytes nodeProof = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodeproof());

    // required uint32 protoVersion = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->protoversion());

    // required uint32 protoVersionMin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->protoversionmin());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 60u) {
    // optional string fullVersion = 5;
    if (has_fullversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fullversion());
    }

    // optional bytes ledgerClosed = 9;
    if (has_ledgerclosed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerclosed());
    }

    // optional bytes ledgerPrevious = 10;
    if (has_ledgerprevious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerprevious());
    }

    // optional .protocol.TMProofWork proofOfWork = 12;
    if (has_proofofwork()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->proofofwork_);
    }

  }
  if (_has_bits_[8 / 32] & 32512u) {
    // optional uint64 netTime = 6;
    if (has_nettime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nettime());
    }

    // optional uint32 ipv4Port = 7;
    if (has_ipv4port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipv4port());
    }

    // optional uint32 ledgerIndex = 8;
    if (has_ledgerindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerindex());
    }

    // optional bool nodePrivate = 11;
    if (has_nodeprivate()) {
      total_size += 1 + 1;
    }

    // optional bool testNet = 13;
    if (has_testnet()) {
      total_size += 1 + 1;
    }

    // optional uint32 local_ip = 14;
    if (has_local_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->local_ip());
    }

    // optional uint32 remote_ip = 15;
    if (has_remote_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remote_ip());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMHello::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHello)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHello* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMHello>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHello)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHello)
    MergeFrom(*source);
  }
}

void TMHello::MergeFrom(const TMHello& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHello)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nodepublic();
      nodepublic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepublic_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_nodeproof();
      nodeproof_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeproof_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_fullversion();
      fullversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fullversion_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_ledgerclosed();
      ledgerclosed_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerclosed_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_ledgerprevious();
      ledgerprevious_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerprevious_);
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_proofofwork()->::protocol::TMProofWork::MergeFrom(from.proofofwork());
    }
    if (cached_has_bits & 0x00000040u) {
      protoversion_ = from.protoversion_;
    }
    if (cached_has_bits & 0x00000080u) {
      protoversionmin_ = from.protoversionmin_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 32512u) {
    if (cached_has_bits & 0x00000100u) {
      nettime_ = from.nettime_;
    }
    if (cached_has_bits & 0x00000200u) {
      ipv4port_ = from.ipv4port_;
    }
    if (cached_has_bits & 0x00000400u) {
      ledgerindex_ = from.ledgerindex_;
    }
    if (cached_has_bits & 0x00000800u) {
      nodeprivate_ = from.nodeprivate_;
    }
    if (cached_has_bits & 0x00001000u) {
      testnet_ = from.testnet_;
    }
    if (cached_has_bits & 0x00002000u) {
      local_ip_ = from.local_ip_;
    }
    if (cached_has_bits & 0x00004000u) {
      remote_ip_ = from.remote_ip_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMHello::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHello::CopyFrom(const TMHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHello::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000c3) != 0x000000c3) return false;
  if (has_proofofwork()) {
    if (!this->proofofwork_->IsInitialized()) return false;
  }
  return true;
}

void TMHello::Swap(TMHello* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMHello::InternalSwap(TMHello* other) {
  using std::swap;
  nodepublic_.Swap(&other->nodepublic_);
  nodeproof_.Swap(&other->nodeproof_);
  fullversion_.Swap(&other->fullversion_);
  ledgerclosed_.Swap(&other->ledgerclosed_);
  ledgerprevious_.Swap(&other->ledgerprevious_);
  swap(proofofwork_, other->proofofwork_);
  swap(protoversion_, other->protoversion_);
  swap(protoversionmin_, other->protoversionmin_);
  swap(nettime_, other->nettime_);
  swap(ipv4port_, other->ipv4port_);
  swap(ledgerindex_, other->ledgerindex_);
  swap(nodeprivate_, other->nodeprivate_);
  swap(testnet_, other->testnet_);
  swap(local_ip_, other->local_ip_);
  swap(remote_ip_, other->remote_ip_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMHello::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMClusterNode::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMClusterNode::kPublicKeyFieldNumber;
const int TMClusterNode::kReportTimeFieldNumber;
const int TMClusterNode::kNodeLoadFieldNumber;
const int TMClusterNode::kNodeNameFieldNumber;
const int TMClusterNode::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMClusterNode::TMClusterNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMClusterNode();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMClusterNode)
}
TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_publickey()) {
    publickey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.publickey_);
  }
  nodename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodename()) {
    nodename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodename_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  ::memcpy(&reporttime_, &from.reporttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&nodeload_) -
    reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMClusterNode)
}

void TMClusterNode::SharedCtor() {
  _cached_size_ = 0;
  publickey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&reporttime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nodeload_) -
      reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
}

TMClusterNode::~TMClusterNode() {
  // @@protoc_insertion_point(destructor:protocol.TMClusterNode)
  SharedDtor();
}

void TMClusterNode::SharedDtor() {
  publickey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMClusterNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMClusterNode::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMClusterNode& TMClusterNode::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMClusterNode();
  return *internal_default_instance();
}

TMClusterNode* TMClusterNode::New(::google::protobuf::Arena* arena) const {
  TMClusterNode* n = new TMClusterNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMClusterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMClusterNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!publickey_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*publickey_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!nodename_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodename_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 24u) {
    ::memset(&reporttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nodeload_) -
        reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMClusterNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMClusterNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string publicKey = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_publickey()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->publickey().data(), static_cast<int>(this->publickey().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.publicKey");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 reportTime = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_reporttime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reporttime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 nodeLoad = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_nodeload();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nodeload_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string nodeName = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nodename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->nodename().data(), static_cast<int>(this->nodename().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.nodeName");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMClusterNode.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMClusterNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMClusterNode)
  return false;
#undef DO_
}

void TMClusterNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMClusterNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->publickey().data(), static_cast<int>(this->publickey().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->publickey(), output);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->reporttime(), output);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nodeload(), output);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nodename().data(), static_cast<int>(this->nodename().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->nodename(), output);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMClusterNode)
}

::google::protobuf::uint8* TMClusterNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMClusterNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->publickey().data(), static_cast<int>(this->publickey().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->nodeload(), target);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nodename().data(), static_cast<int>(this->nodename().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->nodename(), target);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMClusterNode)
  return target;
}

size_t TMClusterNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (has_publickey()) {
    // required string publicKey = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->publickey());
  }

  if (has_reporttime()) {
    // required uint32 reportTime = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reporttime());
  }

  if (has_nodeload()) {
    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->nodeload());
  }

  return total_size;
}
size_t TMClusterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string publicKey = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->publickey());

    // required uint32 reportTime = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reporttime());

    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->nodeload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 6u) {
    // optional string nodeName = 4;
    if (has_nodename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nodename());
    }

    // optional string address = 5;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMClusterNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMClusterNode* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMClusterNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMClusterNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMClusterNode)
    MergeFrom(*source);
  }
}

void TMClusterNode::MergeFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_publickey();
      publickey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.publickey_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_nodename();
      nodename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodename_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000008u) {
      reporttime_ = from.reporttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      nodeload_ = from.nodeload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMClusterNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;
  return true;
}

void TMClusterNode::Swap(TMClusterNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMClusterNode::InternalSwap(TMClusterNode* other) {
  using std::swap;
  publickey_.Swap(&other->publickey_);
  nodename_.Swap(&other->nodename_);
  address_.Swap(&other->address_);
  swap(reporttime_, other->reporttime_);
  swap(nodeload_, other->nodeload_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMClusterNode::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMLoadSource::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLoadSource::kNameFieldNumber;
const int TMLoadSource::kCostFieldNumber;
const int TMLoadSource::kCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLoadSource::TMLoadSource()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMLoadSource();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLoadSource)
}
TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&cost_, &from.cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLoadSource)
}

void TMLoadSource::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&cost_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&cost_)) + sizeof(count_));
}

TMLoadSource::~TMLoadSource() {
  // @@protoc_insertion_point(destructor:protocol.TMLoadSource)
  SharedDtor();
}

void TMLoadSource::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMLoadSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLoadSource::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMLoadSource& TMLoadSource::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMLoadSource();
  return *internal_default_instance();
}

TMLoadSource* TMLoadSource::New(::google::protobuf::Arena* arena) const {
  TMLoadSource* n = new TMLoadSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMLoadSource::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLoadSource)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 6u) {
    ::memset(&cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMLoadSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLoadSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "protocol.TMLoadSource.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 cost = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_cost();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cost_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLoadSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLoadSource)
  return false;
#undef DO_
}

void TMLoadSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLoadSource)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cost(), output);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLoadSource)
}

::google::protobuf::uint8* TMLoadSource::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLoadSource)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cost(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLoadSource)
  return target;
}

size_t TMLoadSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_cost()) {
    // required uint32 cost = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cost());
  }

  return total_size;
}
size_t TMLoadSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required uint32 cost = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cost());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint32 count = 3;
  if (has_count()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->count());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLoadSource::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLoadSource* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMLoadSource>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLoadSource)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLoadSource)
    MergeFrom(*source);
  }
}

void TMLoadSource::MergeFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      cost_ = from.cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLoadSource::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMLoadSource::Swap(TMLoadSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLoadSource::InternalSwap(TMLoadSource* other) {
  using std::swap;
  name_.Swap(&other->name_);
  swap(cost_, other->cost_);
  swap(count_, other->count_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMLoadSource::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMCluster::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMCluster::kClusterNodesFieldNumber;
const int TMCluster::kLoadSourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMCluster::TMCluster()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMCluster();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMCluster)
}
TMCluster::TMCluster(const TMCluster& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      clusternodes_(from.clusternodes_),
      loadsources_(from.loadsources_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMCluster)
}

void TMCluster::SharedCtor() {
  _cached_size_ = 0;
}

TMCluster::~TMCluster() {
  // @@protoc_insertion_point(destructor:protocol.TMCluster)
  SharedDtor();
}

void TMCluster::SharedDtor() {
}

void TMCluster::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMCluster::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMCluster& TMCluster::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMCluster();
  return *internal_default_instance();
}

TMCluster* TMCluster::New(::google::protobuf::Arena* arena) const {
  TMCluster* n = new TMCluster;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMCluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clusternodes_.Clear();
  loadsources_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMCluster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMCluster)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_clusternodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_loadsources()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMCluster)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMCluster)
  return false;
#undef DO_
}

void TMCluster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMCluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusternodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->clusternodes(static_cast<int>(i)), output);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->loadsources_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->loadsources(static_cast<int>(i)), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMCluster)
}

::google::protobuf::uint8* TMCluster::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMCluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusternodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->clusternodes(static_cast<int>(i)), deterministic, target);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->loadsources_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->loadsources(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMCluster)
  return target;
}

size_t TMCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMCluster)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .protocol.TMClusterNode clusterNodes = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->clusternodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->clusternodes(static_cast<int>(i)));
    }
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->loadsources_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->loadsources(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMCluster::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  const TMCluster* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMCluster>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMCluster)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMCluster)
    MergeFrom(*source);
  }
}

void TMCluster::MergeFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  clusternodes_.MergeFrom(from.clusternodes_);
  loadsources_.MergeFrom(from.loadsources_);
}

void TMCluster::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMCluster::CopyFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->clusternodes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->loadsources())) return false;
  return true;
}

void TMCluster::Swap(TMCluster* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMCluster::InternalSwap(TMCluster* other) {
  using std::swap;
  clusternodes_.InternalSwap(&other->clusternodes_);
  loadsources_.InternalSwap(&other->loadsources_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMCluster::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMTransaction::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMTransaction::kRawTransactionFieldNumber;
const int TMTransaction::kStatusFieldNumber;
const int TMTransaction::kReceiveTimestampFieldNumber;
const int TMTransaction::kDeferredFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMTransaction::TMTransaction()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMTransaction();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMTransaction)
}
TMTransaction::TMTransaction(const TMTransaction& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  rawtransaction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_rawtransaction()) {
    rawtransaction_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rawtransaction_);
  }
  ::memcpy(&receivetimestamp_, &from.receivetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransaction)
}

void TMTransaction::SharedCtor() {
  _cached_size_ = 0;
  rawtransaction_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&receivetimestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deferred_) -
      reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
  status_ = 1;
}

TMTransaction::~TMTransaction() {
  // @@protoc_insertion_point(destructor:protocol.TMTransaction)
  SharedDtor();
}

void TMTransaction::SharedDtor() {
  rawtransaction_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMTransaction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMTransaction::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMTransaction& TMTransaction::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMTransaction();
  return *internal_default_instance();
}

TMTransaction* TMTransaction::New(::google::protobuf::Arena* arena) const {
  TMTransaction* n = new TMTransaction;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransaction)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!rawtransaction_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*rawtransaction_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 14u) {
    ::memset(&receivetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&deferred_) -
        reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMTransaction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMTransaction)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes rawTransaction = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_rawtransaction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TransactionStatus status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TransactionStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TransactionStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 receiveTimestamp = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_receivetimestamp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &receivetimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool deferred = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_deferred();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deferred_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMTransaction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMTransaction)
  return false;
#undef DO_
}

void TMTransaction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMTransaction)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->rawtransaction(), output);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->receivetimestamp(), output);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->deferred(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMTransaction)
}

::google::protobuf::uint8* TMTransaction::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransaction)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->deferred(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransaction)
  return target;
}

size_t TMTransaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (has_rawtransaction()) {
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->rawtransaction());
  }

  if (has_status()) {
    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  return total_size;
}
size_t TMTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->rawtransaction());

    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 6u) {
    // optional uint64 receiveTimestamp = 3;
    if (has_receivetimestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->receivetimestamp());
    }

    // optional bool deferred = 4;
    if (has_deferred()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMTransaction::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  const TMTransaction* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMTransaction>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMTransaction)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMTransaction)
    MergeFrom(*source);
  }
}

void TMTransaction::MergeFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_rawtransaction();
      rawtransaction_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rawtransaction_);
    }
    if (cached_has_bits & 0x00000002u) {
      receivetimestamp_ = from.receivetimestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      deferred_ = from.deferred_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMTransaction::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  return true;
}

void TMTransaction::Swap(TMTransaction* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMTransaction::InternalSwap(TMTransaction* other) {
  using std::swap;
  rawtransaction_.Swap(&other->rawtransaction_);
  swap(receivetimestamp_, other->receivetimestamp_);
  swap(deferred_, other->deferred_);
  swap(status_, other->status_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMTransaction::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMStatusChange::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMStatusChange::kNewStatusFieldNumber;
const int TMStatusChange::kNewEventFieldNumber;
const int TMStatusChange::kLedgerSeqFieldNumber;
const int TMStatusChange::kLedgerHashFieldNumber;
const int TMStatusChange::kLedgerHashPreviousFieldNumber;
const int TMStatusChange::kNetworkTimeFieldNumber;
const int TMStatusChange::kFirstSeqFieldNumber;
const int TMStatusChange::kLastSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMStatusChange::TMStatusChange()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMStatusChange();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMStatusChange)
}
TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ledgerhashprevious_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhashprevious()) {
    ledgerhashprevious_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhashprevious_);
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&newevent_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(newevent_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMStatusChange)
}

void TMStatusChange::SharedCtor() {
  _cached_size_ = 0;
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastseq_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
  newstatus_ = 1;
  newevent_ = 1;
}

TMStatusChange::~TMStatusChange() {
  // @@protoc_insertion_point(destructor:protocol.TMStatusChange)
  SharedDtor();
}

void TMStatusChange::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMStatusChange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMStatusChange::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMStatusChange& TMStatusChange::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMStatusChange();
  return *internal_default_instance();
}

TMStatusChange* TMStatusChange::New(::google::protobuf::Arena* arena) const {
  TMStatusChange* n = new TMStatusChange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMStatusChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!ledgerhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ledgerhash_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!ledgerhashprevious_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ledgerhashprevious_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 252u) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastseq_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
    newstatus_ = 1;
    newevent_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMStatusChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMStatusChange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeStatus_IsValid(value)) {
            set_newstatus(static_cast< ::protocol::NodeStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.NodeEvent newEvent = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::NodeEvent_IsValid(value)) {
            set_newevent(static_cast< ::protocol::NodeEvent >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_ledgerseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHashPrevious = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhashprevious()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 networkTime = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_networktime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &networktime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 firstSeq = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_firstseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &firstseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lastSeq = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_lastseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMStatusChange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMStatusChange)
  return false;
#undef DO_
}

void TMStatusChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMStatusChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->newstatus(), output);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->newevent(), output);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ledgerseq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->ledgerhash(), output);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->ledgerhashprevious(), output);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->networktime(), output);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->firstseq(), output);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->lastseq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMStatusChange)
}

::google::protobuf::uint8* TMStatusChange::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMStatusChange)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->lastseq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMStatusChange)
  return target;
}

size_t TMStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMStatusChange)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes ledgerHash = 4;
    if (has_ledgerhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (has_ledgerhashprevious()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ledgerhashprevious());
    }

    // optional uint32 ledgerSeq = 3;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional uint32 firstSeq = 7;
    if (has_firstseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->firstseq());
    }

    // optional uint64 networkTime = 6;
    if (has_networktime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->networktime());
    }

    // optional uint32 lastSeq = 8;
    if (has_lastseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastseq());
    }

    // optional .protocol.NodeStatus newStatus = 1;
    if (has_newstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (has_newevent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->newevent());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMStatusChange::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  const TMStatusChange* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMStatusChange>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMStatusChange)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMStatusChange)
    MergeFrom(*source);
  }
}

void TMStatusChange::MergeFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ledgerhash();
      ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_ledgerhashprevious();
      ledgerhashprevious_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhashprevious_);
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000008u) {
      firstseq_ = from.firstseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      networktime_ = from.networktime_;
    }
    if (cached_has_bits & 0x00000020u) {
      lastseq_ = from.lastseq_;
    }
    if (cached_has_bits & 0x00000040u) {
      newstatus_ = from.newstatus_;
    }
    if (cached_has_bits & 0x00000080u) {
      newevent_ = from.newevent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMStatusChange::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {
  return true;
}

void TMStatusChange::Swap(TMStatusChange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMStatusChange::InternalSwap(TMStatusChange* other) {
  using std::swap;
  ledgerhash_.Swap(&other->ledgerhash_);
  ledgerhashprevious_.Swap(&other->ledgerhashprevious_);
  swap(ledgerseq_, other->ledgerseq_);
  swap(firstseq_, other->firstseq_);
  swap(networktime_, other->networktime_);
  swap(lastseq_, other->lastseq_);
  swap(newstatus_, other->newstatus_);
  swap(newevent_, other->newevent_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMStatusChange::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMProposeSet::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMProposeSet::kProposeSeqFieldNumber;
const int TMProposeSet::kCurrentTxHashFieldNumber;
const int TMProposeSet::kNodePubKeyFieldNumber;
const int TMProposeSet::kCloseTimeFieldNumber;
const int TMProposeSet::kSignatureFieldNumber;
const int TMProposeSet::kPreviousledgerFieldNumber;
const int TMProposeSet::kCheckedSignatureFieldNumber;
const int TMProposeSet::kAddedTransactionsFieldNumber;
const int TMProposeSet::kRemovedTransactionsFieldNumber;
const int TMProposeSet::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMProposeSet::TMProposeSet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMProposeSet();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMProposeSet)
}
TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      addedtransactions_(from.addedtransactions_),
      removedtransactions_(from.removedtransactions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  currenttxhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_currenttxhash()) {
    currenttxhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.currenttxhash_);
  }
  nodepubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodepubkey()) {
    nodepubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  previousledger_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_previousledger()) {
    previousledger_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.previousledger_);
  }
  ::memcpy(&proposeseq_, &from.proposeseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProposeSet)
}

void TMProposeSet::SharedCtor() {
  _cached_size_ = 0;
  currenttxhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  previousledger_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&proposeseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
}

TMProposeSet::~TMProposeSet() {
  // @@protoc_insertion_point(destructor:protocol.TMProposeSet)
  SharedDtor();
}

void TMProposeSet::SharedDtor() {
  currenttxhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  previousledger_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMProposeSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMProposeSet::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMProposeSet& TMProposeSet::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMProposeSet();
  return *internal_default_instance();
}

TMProposeSet* TMProposeSet::New(::google::protobuf::Arena* arena) const {
  TMProposeSet* n = new TMProposeSet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMProposeSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProposeSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addedtransactions_.Clear();
  removedtransactions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!currenttxhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*currenttxhash_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!nodepubkey_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodepubkey_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!signature_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!previousledger_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*previousledger_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 240u) {
    ::memset(&proposeseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMProposeSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMProposeSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 proposeSeq = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_proposeseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &proposeseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes currentTxHash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_currenttxhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes nodePubKey = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodepubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 closeTime = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_closetime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &closetime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes signature = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes previousledger = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_previousledger()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool checkedSignature = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_checkedsignature();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes addedTransactions = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_addedtransactions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes removedTransactions = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_removedtransactions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hops = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          set_has_hops();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMProposeSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMProposeSet)
  return false;
#undef DO_
}

void TMProposeSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMProposeSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->proposeseq(), output);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->currenttxhash(), output);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nodepubkey(), output);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->closetime(), output);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->signature(), output);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->previousledger(), output);
  }

  // optional bool checkedSignature = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->checkedsignature(), output);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      10, this->addedtransactions(i), output);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->removedtransactions(i), output);
  }

  // optional uint32 hops = 12;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMProposeSet)
}

::google::protobuf::uint8* TMProposeSet::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProposeSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->closetime(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->signature(), target);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->previousledger(), target);
  }

  // optional bool checkedSignature = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(10, this->addedtransactions(i), target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(11, this->removedtransactions(i), target);
  }

  // optional uint32 hops = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProposeSet)
  return target;
}

size_t TMProposeSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (has_currenttxhash()) {
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->currenttxhash());
  }

  if (has_nodepubkey()) {
    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodepubkey());
  }

  if (has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  if (has_previousledger()) {
    // required bytes previousledger = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->previousledger());
  }

  if (has_proposeseq()) {
    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->proposeseq());
  }

  if (has_closetime()) {
    // required uint32 closeTime = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->closetime());
  }

  return total_size;
}
size_t TMProposeSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->currenttxhash());

    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodepubkey());

    // required bytes signature = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());

    // required bytes previousledger = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->previousledger());

    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->proposeseq());

    // required uint32 closeTime = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->closetime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated bytes addedTransactions = 10;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->addedtransactions_size());
  for (int i = 0, n = this->addedtransactions_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->addedtransactions(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->removedtransactions_size());
  for (int i = 0, n = this->removedtransactions_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->removedtransactions(i));
  }

  if (_has_bits_[0 / 32] & 192u) {
    // optional bool checkedSignature = 7;
    if (has_checkedsignature()) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 12;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMProposeSet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProposeSet* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMProposeSet>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProposeSet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProposeSet)
    MergeFrom(*source);
  }
}

void TMProposeSet::MergeFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  addedtransactions_.MergeFrom(from.addedtransactions_);
  removedtransactions_.MergeFrom(from.removedtransactions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_currenttxhash();
      currenttxhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.currenttxhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_nodepubkey();
      nodepubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepubkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_previousledger();
      previousledger_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.previousledger_);
    }
    if (cached_has_bits & 0x00000010u) {
      proposeseq_ = from.proposeseq_;
    }
    if (cached_has_bits & 0x00000020u) {
      closetime_ = from.closetime_;
    }
    if (cached_has_bits & 0x00000040u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000080u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProposeSet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void TMProposeSet::Swap(TMProposeSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMProposeSet::InternalSwap(TMProposeSet* other) {
  using std::swap;
  addedtransactions_.InternalSwap(&other->addedtransactions_);
  removedtransactions_.InternalSwap(&other->removedtransactions_);
  currenttxhash_.Swap(&other->currenttxhash_);
  nodepubkey_.Swap(&other->nodepubkey_);
  signature_.Swap(&other->signature_);
  previousledger_.Swap(&other->previousledger_);
  swap(proposeseq_, other->proposeseq_);
  swap(closetime_, other->closetime_);
  swap(checkedsignature_, other->checkedsignature_);
  swap(hops_, other->hops_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMProposeSet::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMHaveTransactionSet::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMHaveTransactionSet::kStatusFieldNumber;
const int TMHaveTransactionSet::kHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMHaveTransactionSet::TMHaveTransactionSet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMHaveTransactionSet();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMHaveTransactionSet)
}
TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactionSet)
}

void TMHaveTransactionSet::SharedCtor() {
  _cached_size_ = 0;
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_ = 1;
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactionSet)
  SharedDtor();
}

void TMHaveTransactionSet::SharedDtor() {
  hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMHaveTransactionSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMHaveTransactionSet::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMHaveTransactionSet& TMHaveTransactionSet::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMHaveTransactionSet();
  return *internal_default_instance();
}

TMHaveTransactionSet* TMHaveTransactionSet::New(::google::protobuf::Arena* arena) const {
  TMHaveTransactionSet* n = new TMHaveTransactionSet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMHaveTransactionSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactionSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!hash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hash_.UnsafeRawStringPointer())->clear();
    }
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMHaveTransactionSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMHaveTransactionSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TxSetStatus status = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TxSetStatus_IsValid(value)) {
            set_status(static_cast< ::protocol::TxSetStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes hash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMHaveTransactionSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMHaveTransactionSet)
  return false;
#undef DO_
}

void TMHaveTransactionSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMHaveTransactionSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMHaveTransactionSet)
}

::google::protobuf::uint8* TMHaveTransactionSet::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactionSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactionSet)
  return target;
}

size_t TMHaveTransactionSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->hash());
  }

  if (has_status()) {
    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  return total_size;
}
size_t TMHaveTransactionSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->hash());

    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMHaveTransactionSet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHaveTransactionSet* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMHaveTransactionSet>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHaveTransactionSet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHaveTransactionSet)
    MergeFrom(*source);
  }
}

void TMHaveTransactionSet::MergeFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_hash();
      hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMHaveTransactionSet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMHaveTransactionSet::Swap(TMHaveTransactionSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMHaveTransactionSet::InternalSwap(TMHaveTransactionSet* other) {
  using std::swap;
  hash_.Swap(&other->hash_);
  swap(status_, other->status_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMHaveTransactionSet::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMValidation::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMValidation::kValidationFieldNumber;
const int TMValidation::kCheckedSignatureFieldNumber;
const int TMValidation::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMValidation::TMValidation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMValidation();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMValidation)
}
TMValidation::TMValidation(const TMValidation& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  validation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_validation()) {
    validation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.validation_);
  }
  ::memcpy(&checkedsignature_, &from.checkedsignature_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidation)
}

void TMValidation::SharedCtor() {
  _cached_size_ = 0;
  validation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&checkedsignature_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
}

TMValidation::~TMValidation() {
  // @@protoc_insertion_point(destructor:protocol.TMValidation)
  SharedDtor();
}

void TMValidation::SharedDtor() {
  validation_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMValidation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMValidation::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMValidation& TMValidation::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMValidation();
  return *internal_default_instance();
}

TMValidation* TMValidation::New(::google::protobuf::Arena* arena) const {
  TMValidation* n = new TMValidation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!validation_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*validation_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 6u) {
    ::memset(&checkedsignature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMValidation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMValidation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes validation = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_validation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool checkedSignature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_checkedsignature();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkedsignature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hops = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_hops();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMValidation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMValidation)
  return false;
#undef DO_
}

void TMValidation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMValidation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->validation(), output);
  }

  // optional bool checkedSignature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->checkedsignature(), output);
  }

  // optional uint32 hops = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMValidation)
}

::google::protobuf::uint8* TMValidation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->validation(), target);
  }

  // optional bool checkedSignature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->checkedsignature(), target);
  }

  // optional uint32 hops = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidation)
  return target;
}

size_t TMValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidation)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes validation = 1;
  if (has_validation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->validation());
  }
  if (_has_bits_[0 / 32] & 6u) {
    // optional bool checkedSignature = 2;
    if (has_checkedsignature()) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hops());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMValidation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidation* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMValidation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidation)
    MergeFrom(*source);
  }
}

void TMValidation::MergeFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_validation();
      validation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.validation_);
    }
    if (cached_has_bits & 0x00000002u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000004u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidation::CopyFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMValidation::Swap(TMValidation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMValidation::InternalSwap(TMValidation* other) {
  using std::swap;
  validation_.Swap(&other->validation_);
  swap(checkedsignature_, other->checkedsignature_);
  swap(hops_, other->hops_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMValidation::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMGetPeers::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetPeers::kDoWeNeedThisFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetPeers::TMGetPeers()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMGetPeers();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetPeers)
}
TMGetPeers::TMGetPeers(const TMGetPeers& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  doweneedthis_ = from.doweneedthis_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeers)
}

void TMGetPeers::SharedCtor() {
  _cached_size_ = 0;
  doweneedthis_ = 0u;
}

TMGetPeers::~TMGetPeers() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeers)
  SharedDtor();
}

void TMGetPeers::SharedDtor() {
}

void TMGetPeers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetPeers::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMGetPeers& TMGetPeers::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMGetPeers();
  return *internal_default_instance();
}

TMGetPeers* TMGetPeers::New(::google::protobuf::Arena* arena) const {
  TMGetPeers* n = new TMGetPeers;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMGetPeers::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  doweneedthis_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMGetPeers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetPeers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 doWeNeedThis = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_doweneedthis();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &doweneedthis_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetPeers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetPeers)
  return false;
#undef DO_
}

void TMGetPeers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 doWeNeedThis = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->doweneedthis(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetPeers)
}

::google::protobuf::uint8* TMGetPeers::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 doWeNeedThis = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->doweneedthis(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeers)
  return target;
}

size_t TMGetPeers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeers)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 doWeNeedThis = 1;
  if (has_doweneedthis()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->doweneedthis());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetPeers::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetPeers)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetPeers* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMGetPeers>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetPeers)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetPeers)
    MergeFrom(*source);
  }
}

void TMGetPeers::MergeFrom(const TMGetPeers& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeers)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_doweneedthis()) {
    set_doweneedthis(from.doweneedthis());
  }
}

void TMGetPeers::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetPeers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeers::CopyFrom(const TMGetPeers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMGetPeers::Swap(TMGetPeers* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetPeers::InternalSwap(TMGetPeers* other) {
  using std::swap;
  swap(doweneedthis_, other->doweneedthis_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMGetPeers::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMIPv4Endpoint::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMIPv4Endpoint::kIpv4FieldNumber;
const int TMIPv4Endpoint::kIpv4PortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMIPv4Endpoint::TMIPv4Endpoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMIPv4Endpoint();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMIPv4Endpoint)
}
TMIPv4Endpoint::TMIPv4Endpoint(const TMIPv4Endpoint& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&ipv4_, &from.ipv4_,
    static_cast<size_t>(reinterpret_cast<char*>(&ipv4port_) -
    reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMIPv4Endpoint)
}

void TMIPv4Endpoint::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&ipv4_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ipv4port_) -
      reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
}

TMIPv4Endpoint::~TMIPv4Endpoint() {
  // @@protoc_insertion_point(destructor:protocol.TMIPv4Endpoint)
  SharedDtor();
}

void TMIPv4Endpoint::SharedDtor() {
}

void TMIPv4Endpoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMIPv4Endpoint::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMIPv4Endpoint& TMIPv4Endpoint::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMIPv4Endpoint();
  return *internal_default_instance();
}

TMIPv4Endpoint* TMIPv4Endpoint::New(::google::protobuf::Arena* arena) const {
  TMIPv4Endpoint* n = new TMIPv4Endpoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMIPv4Endpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIPv4Endpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&ipv4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ipv4port_) -
        reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMIPv4Endpoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMIPv4Endpoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ipv4 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_ipv4();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 ipv4Port = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_ipv4port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipv4port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMIPv4Endpoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMIPv4Endpoint)
  return false;
#undef DO_
}

void TMIPv4Endpoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMIPv4Endpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ipv4(), output);
  }

  // required uint32 ipv4Port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ipv4port(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMIPv4Endpoint)
}

::google::protobuf::uint8* TMIPv4Endpoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIPv4Endpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ipv4(), target);
  }

  // required uint32 ipv4Port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ipv4port(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIPv4Endpoint)
  return target;
}

size_t TMIPv4Endpoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMIPv4Endpoint)
  size_t total_size = 0;

  if (has_ipv4()) {
    // required uint32 ipv4 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipv4());
  }

  if (has_ipv4port()) {
    // required uint32 ipv4Port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipv4port());
  }

  return total_size;
}
size_t TMIPv4Endpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIPv4Endpoint)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 ipv4 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipv4());

    // required uint32 ipv4Port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipv4port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMIPv4Endpoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIPv4Endpoint)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIPv4Endpoint* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMIPv4Endpoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIPv4Endpoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIPv4Endpoint)
    MergeFrom(*source);
  }
}

void TMIPv4Endpoint::MergeFrom(const TMIPv4Endpoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIPv4Endpoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      ipv4_ = from.ipv4_;
    }
    if (cached_has_bits & 0x00000002u) {
      ipv4port_ = from.ipv4port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIPv4Endpoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIPv4Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIPv4Endpoint::CopyFrom(const TMIPv4Endpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIPv4Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIPv4Endpoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TMIPv4Endpoint::Swap(TMIPv4Endpoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMIPv4Endpoint::InternalSwap(TMIPv4Endpoint* other) {
  using std::swap;
  swap(ipv4_, other->ipv4_);
  swap(ipv4port_, other->ipv4port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMIPv4Endpoint::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMPeers::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMPeers::kNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMPeers::TMPeers()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMPeers();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMPeers)
}
TMPeers::TMPeers(const TMPeers& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeers)
}

void TMPeers::SharedCtor() {
  _cached_size_ = 0;
}

TMPeers::~TMPeers() {
  // @@protoc_insertion_point(destructor:protocol.TMPeers)
  SharedDtor();
}

void TMPeers::SharedDtor() {
}

void TMPeers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMPeers::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMPeers& TMPeers::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMPeers();
  return *internal_default_instance();
}

TMPeers* TMPeers::New(::google::protobuf::Arena* arena) const {
  TMPeers* n = new TMPeers;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMPeers::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMPeers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMPeers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protocol.TMIPv4Endpoint nodes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMPeers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMPeers)
  return false;
#undef DO_
}

void TMPeers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(static_cast<int>(i)), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMPeers)
}

::google::protobuf::uint8* TMPeers::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeers)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->nodes(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeers)
  return target;
}

size_t TMPeers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeers)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .protocol.TMIPv4Endpoint nodes = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->nodes(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMPeers::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeers)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeers* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMPeers>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeers)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeers)
    MergeFrom(*source);
  }
}

void TMPeers::MergeFrom(const TMPeers& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeers)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
}

void TMPeers::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeers::CopyFrom(const TMPeers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeers::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->nodes())) return false;
  return true;
}

void TMPeers::Swap(TMPeers* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMPeers::InternalSwap(TMPeers* other) {
  using std::swap;
  nodes_.InternalSwap(&other->nodes_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMPeers::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMEndpoint::InitAsDefaultInstance() {
  ::protocol::_TMEndpoint_default_instance_._instance.get_mutable()->ipv4_ = const_cast< ::protocol::TMIPv4Endpoint*>(
      ::protocol::TMIPv4Endpoint::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMEndpoint::kIpv4FieldNumber;
const int TMEndpoint::kHopsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMEndpoint::TMEndpoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMEndpoint();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMEndpoint)
}
TMEndpoint::TMEndpoint(const TMEndpoint& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_ipv4()) {
    ipv4_ = new ::protocol::TMIPv4Endpoint(*from.ipv4_);
  } else {
    ipv4_ = NULL;
  }
  hops_ = from.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoint)
}

void TMEndpoint::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&ipv4_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&ipv4_)) + sizeof(hops_));
}

TMEndpoint::~TMEndpoint() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoint)
  SharedDtor();
}

void TMEndpoint::SharedDtor() {
  if (this != internal_default_instance()) delete ipv4_;
}

void TMEndpoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMEndpoint::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMEndpoint& TMEndpoint::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMEndpoint();
  return *internal_default_instance();
}

TMEndpoint* TMEndpoint::New(::google::protobuf::Arena* arena) const {
  TMEndpoint* n = new TMEndpoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(ipv4_ != NULL);
    ipv4_->Clear();
  }
  hops_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMEndpoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMEndpoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMIPv4Endpoint ipv4 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_ipv4()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 hops = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_hops();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hops_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMEndpoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMEndpoint)
  return false;
#undef DO_
}

void TMEndpoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMEndpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->ipv4_, output);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->hops(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMEndpoint)
}

::google::protobuf::uint8* TMEndpoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->ipv4_, deterministic, target);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->hops(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoint)
  return target;
}

size_t TMEndpoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoint)
  size_t total_size = 0;

  if (has_ipv4()) {
    // required .protocol.TMIPv4Endpoint ipv4 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->ipv4_);
  }

  if (has_hops()) {
    // required uint32 hops = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->hops());
  }

  return total_size;
}
size_t TMEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoint)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .protocol.TMIPv4Endpoint ipv4 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->ipv4_);

    // required uint32 hops = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMEndpoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoint)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoint* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMEndpoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoint)
    MergeFrom(*source);
  }
}

void TMEndpoint::MergeFrom(const TMEndpoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_ipv4()->::protocol::TMIPv4Endpoint::MergeFrom(from.ipv4());
    }
    if (cached_has_bits & 0x00000002u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMEndpoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoint::CopyFrom(const TMEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_ipv4()) {
    if (!this->ipv4_->IsInitialized()) return false;
  }
  return true;
}

void TMEndpoint::Swap(TMEndpoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMEndpoint::InternalSwap(TMEndpoint* other) {
  using std::swap;
  swap(ipv4_, other->ipv4_);
  swap(hops_, other->hops_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMEndpoint::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMEndpoints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMEndpoints::kVersionFieldNumber;
const int TMEndpoints::kEndpointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMEndpoints::TMEndpoints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMEndpoints();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMEndpoints)
}
TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      endpoints_(from.endpoints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints)
}

void TMEndpoints::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
}

TMEndpoints::~TMEndpoints() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints)
  SharedDtor();
}

void TMEndpoints::SharedDtor() {
}

void TMEndpoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMEndpoints::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMEndpoints& TMEndpoints::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMEndpoints();
  return *internal_default_instance();
}

TMEndpoints* TMEndpoints::New(::google::protobuf::Arena* arena) const {
  TMEndpoints* n = new TMEndpoints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_.Clear();
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMEndpoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMEndpoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMEndpoint endpoints = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_endpoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMEndpoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMEndpoints)
  return false;
#undef DO_
}

void TMEndpoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMEndpoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .protocol.TMEndpoint endpoints = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->endpoints(static_cast<int>(i)), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMEndpoints)
}

::google::protobuf::uint8* TMEndpoints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .protocol.TMEndpoint endpoints = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->endpoints_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->endpoints(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints)
  return target;
}

size_t TMEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 version = 1;
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->version());
  }
  // repeated .protocol.TMEndpoint endpoints = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->endpoints_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->endpoints(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMEndpoints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMEndpoints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints)
    MergeFrom(*source);
  }
}

void TMEndpoints::MergeFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_.MergeFrom(from.endpoints_);
  if (from.has_version()) {
    set_version(from.version());
  }
}

void TMEndpoints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->endpoints())) return false;
  return true;
}

void TMEndpoints::Swap(TMEndpoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMEndpoints::InternalSwap(TMEndpoints* other) {
  using std::swap;
  endpoints_.InternalSwap(&other->endpoints_);
  swap(version_, other->version_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMEndpoints::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMIndexedObject::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMIndexedObject::kHashFieldNumber;
const int TMIndexedObject::kNodeIDFieldNumber;
const int TMIndexedObject::kIndexFieldNumber;
const int TMIndexedObject::kDataFieldNumber;
const int TMIndexedObject::kLedgerSeqFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMIndexedObject::TMIndexedObject()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMIndexedObject();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMIndexedObject)
}
TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  nodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodeid()) {
    nodeid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
  }
  index_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_index()) {
    index_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.index_);
  }
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  ledgerseq_ = from.ledgerseq_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMIndexedObject)
}

void TMIndexedObject::SharedCtor() {
  _cached_size_ = 0;
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ledgerseq_ = 0u;
}

TMIndexedObject::~TMIndexedObject() {
  // @@protoc_insertion_point(destructor:protocol.TMIndexedObject)
  SharedDtor();
}

void TMIndexedObject::SharedDtor() {
  hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMIndexedObject::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMIndexedObject::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMIndexedObject& TMIndexedObject::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMIndexedObject();
  return *internal_default_instance();
}

TMIndexedObject* TMIndexedObject::New(::google::protobuf::Arena* arena) const {
  TMIndexedObject* n = new TMIndexedObject;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMIndexedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIndexedObject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!hash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hash_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!nodeid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodeid_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!index_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*index_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!data_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*data_.UnsafeRawStringPointer())->clear();
    }
  }
  ledgerseq_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMIndexedObject::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMIndexedObject)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes hash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodeID = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes index = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_index()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_ledgerseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMIndexedObject)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMIndexedObject)
  return false;
#undef DO_
}

void TMIndexedObject::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMIndexedObject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->hash(), output);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodeid(), output);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->index(), output);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ledgerseq(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMIndexedObject)
}

::google::protobuf::uint8* TMIndexedObject::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIndexedObject)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->hash(), target);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->index(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->ledgerseq(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIndexedObject)
  return target;
}

size_t TMIndexedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIndexedObject)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional bytes hash = 1;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional bytes nodeID = 2;
    if (has_nodeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nodeid());
    }

    // optional bytes index = 3;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->index());
    }

    // optional bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional uint32 ledgerSeq = 5;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMIndexedObject::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIndexedObject* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMIndexedObject>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIndexedObject)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIndexedObject)
    MergeFrom(*source);
  }
}

void TMIndexedObject::MergeFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_hash();
      hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_nodeid();
      nodeid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_index();
      index_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.index_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000010u) {
      ledgerseq_ = from.ledgerseq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIndexedObject::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {
  return true;
}

void TMIndexedObject::Swap(TMIndexedObject* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMIndexedObject::InternalSwap(TMIndexedObject* other) {
  using std::swap;
  hash_.Swap(&other->hash_);
  nodeid_.Swap(&other->nodeid_);
  index_.Swap(&other->index_);
  data_.Swap(&other->data_);
  swap(ledgerseq_, other->ledgerseq_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMIndexedObject::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMGetObjectByHash::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetObjectByHash::kTypeFieldNumber;
const int TMGetObjectByHash::kQueryFieldNumber;
const int TMGetObjectByHash::kSeqFieldNumber;
const int TMGetObjectByHash::kLedgerHashFieldNumber;
const int TMGetObjectByHash::kFatFieldNumber;
const int TMGetObjectByHash::kObjectsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetObjectByHash::TMGetObjectByHash()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMGetObjectByHash();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetObjectByHash)
}
TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      objects_(from.objects_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&fat_) -
    reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetObjectByHash)
}

void TMGetObjectByHash::SharedCtor() {
  _cached_size_ = 0;
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fat_) -
      reinterpret_cast<char*>(&type_)) + sizeof(fat_));
}

TMGetObjectByHash::~TMGetObjectByHash() {
  // @@protoc_insertion_point(destructor:protocol.TMGetObjectByHash)
  SharedDtor();
}

void TMGetObjectByHash::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMGetObjectByHash::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetObjectByHash::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMGetObjectByHash& TMGetObjectByHash::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMGetObjectByHash();
  return *internal_default_instance();
}

TMGetObjectByHash* TMGetObjectByHash::New(::google::protobuf::Arena* arena) const {
  TMGetObjectByHash* n = new TMGetObjectByHash;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMGetObjectByHash::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetObjectByHash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  objects_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!ledgerhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*ledgerhash_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 30u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fat_) -
        reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMGetObjectByHash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetObjectByHash)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMGetObjectByHash_ObjectType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMGetObjectByHash_ObjectType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bool query = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_query();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &query_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 seq = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_seq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool fat = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_fat();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMIndexedObject objects = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_objects()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetObjectByHash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetObjectByHash)
  return false;
#undef DO_
}

void TMGetObjectByHash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetObjectByHash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->query(), output);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->seq(), output);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->ledgerhash(), output);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->fat(), output);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->objects_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->objects(static_cast<int>(i)), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetObjectByHash)
}

::google::protobuf::uint8* TMGetObjectByHash::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetObjectByHash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->query(), target);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->objects_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->objects(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetObjectByHash)
  return target;
}

size_t TMGetObjectByHash::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (has_type()) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_query()) {
    // required bool query = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMGetObjectByHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required bool query = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .protocol.TMIndexedObject objects = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->objects_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->objects(static_cast<int>(i)));
    }
  }

  // optional bytes ledgerHash = 4;
  if (has_ledgerhash()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  // optional uint32 seq = 3;
  if (has_seq()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->seq());
  }

  // optional bool fat = 5;
  if (has_fat()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetObjectByHash::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetObjectByHash* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMGetObjectByHash>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetObjectByHash)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetObjectByHash)
    MergeFrom(*source);
  }
}

void TMGetObjectByHash::MergeFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  objects_.MergeFrom(from.objects_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ledgerhash();
      ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000008u) {
      query_ = from.query_;
    }
    if (cached_has_bits & 0x00000010u) {
      fat_ = from.fat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetObjectByHash::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000a) != 0x0000000a) return false;
  return true;
}

void TMGetObjectByHash::Swap(TMGetObjectByHash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetObjectByHash::InternalSwap(TMGetObjectByHash* other) {
  using std::swap;
  objects_.InternalSwap(&other->objects_);
  ledgerhash_.Swap(&other->ledgerhash_);
  swap(type_, other->type_);
  swap(seq_, other->seq_);
  swap(query_, other->query_);
  swap(fat_, other->fat_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMGetObjectByHash::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMLedgerNode::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLedgerNode::kNodedataFieldNumber;
const int TMLedgerNode::kNodeidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLedgerNode::TMLedgerNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMLedgerNode();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLedgerNode)
}
TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nodedata_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodedata()) {
    nodedata_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodedata_);
  }
  nodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nodeid()) {
    nodeid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerNode)
}

void TMLedgerNode::SharedCtor() {
  _cached_size_ = 0;
  nodedata_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

TMLedgerNode::~TMLedgerNode() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerNode)
  SharedDtor();
}

void TMLedgerNode::SharedDtor() {
  nodedata_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLedgerNode::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMLedgerNode& TMLedgerNode::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMLedgerNode();
  return *internal_default_instance();
}

TMLedgerNode* TMLedgerNode::New(::google::protobuf::Arena* arena) const {
  TMLedgerNode* n = new TMLedgerNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMLedgerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!nodedata_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodedata_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!nodeid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nodeid_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMLedgerNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLedgerNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes nodedata = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodedata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nodeid = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nodeid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLedgerNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLedgerNode)
  return false;
#undef DO_
}

void TMLedgerNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLedgerNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nodedata(), output);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nodeid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLedgerNode)
}

::google::protobuf::uint8* TMLedgerNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nodeid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerNode)
  return target;
}

size_t TMLedgerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes nodedata = 1;
  if (has_nodedata()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodedata());
  }
  // optional bytes nodeid = 2;
  if (has_nodeid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nodeid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLedgerNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerNode* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMLedgerNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerNode)
    MergeFrom(*source);
  }
}

void TMLedgerNode::MergeFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nodedata();
      nodedata_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodedata_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_nodeid();
      nodeid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodeid_);
    }
  }
}

void TMLedgerNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMLedgerNode::Swap(TMLedgerNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLedgerNode::InternalSwap(TMLedgerNode* other) {
  using std::swap;
  nodedata_.Swap(&other->nodedata_);
  nodeid_.Swap(&other->nodeid_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMLedgerNode::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMGetLedger::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMGetLedger::kItypeFieldNumber;
const int TMGetLedger::kLtypeFieldNumber;
const int TMGetLedger::kLedgerHashFieldNumber;
const int TMGetLedger::kLedgerSeqFieldNumber;
const int TMGetLedger::kNodeIDsFieldNumber;
const int TMGetLedger::kRequestCookieFieldNumber;
const int TMGetLedger::kQueryTypeFieldNumber;
const int TMGetLedger::kQueryDepthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMGetLedger::TMGetLedger()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMGetLedger();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMGetLedger)
}
TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      nodeids_(from.nodeids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&itype_, &from.itype_,
    static_cast<size_t>(reinterpret_cast<char*>(&querydepth_) -
    reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetLedger)
}

void TMGetLedger::SharedCtor() {
  _cached_size_ = 0;
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&itype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&querydepth_) -
      reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
}

TMGetLedger::~TMGetLedger() {
  // @@protoc_insertion_point(destructor:protocol.TMGetLedger)
  SharedDtor();
}

void TMGetLedger::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMGetLedger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMGetLedger::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMGetLedger& TMGetLedger::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMGetLedger();
  return *internal_default_instance();
}

TMGetLedger* TMGetLedger::New(::google::protobuf::Arena* arena) const {
  TMGetLedger* n = new TMGetLedger;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMGetLedger::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetLedger)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodeids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!ledgerhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*ledgerhash_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 126u) {
    ::memset(&itype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&querydepth_) -
        reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMGetLedger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMGetLedger)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_itype(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMLedgerType ltype = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerType_IsValid(value)) {
            set_ltype(static_cast< ::protocol::TMLedgerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes ledgerHash = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ledgerSeq = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_ledgerseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated bytes nodeIDs = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_nodeids()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 requestCookie = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_requestcookie();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requestcookie_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMQueryType queryType = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMQueryType_IsValid(value)) {
            set_querytype(static_cast< ::protocol::TMQueryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                7, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 queryDepth = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_querydepth();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &querydepth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMGetLedger)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMGetLedger)
  return false;
#undef DO_
}

void TMGetLedger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMGetLedger)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->itype(), output);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->ltype(), output);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->ledgerhash(), output);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->ledgerseq(), output);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->nodeids(i), output);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->requestcookie(), output);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->querytype(), output);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->querydepth(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMGetLedger)
}

::google::protobuf::uint8* TMGetLedger::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetLedger)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(5, this->nodeids(i), target);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->querydepth(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetLedger)
  return target;
}

size_t TMGetLedger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetLedger)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .protocol.TMLedgerInfoType itype = 1;
  if (has_itype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->itype());
  }
  // repeated bytes nodeIDs = 5;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->nodeids_size());
  for (int i = 0, n = this->nodeids_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->nodeids(i));
  }

  // optional bytes ledgerHash = 3;
  if (has_ledgerhash()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (_has_bits_[0 / 32] & 124u) {
    // optional .protocol.TMLedgerType ltype = 2;
    if (has_ltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ltype());
    }

    // optional uint32 ledgerSeq = 4;
    if (has_ledgerseq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ledgerseq());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (has_querytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->querytype());
    }

    // optional uint64 requestCookie = 6;
    if (has_requestcookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requestcookie());
    }

    // optional uint32 queryDepth = 8;
    if (has_querydepth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->querydepth());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMGetLedger::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetLedger* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMGetLedger>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetLedger)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetLedger)
    MergeFrom(*source);
  }
}

void TMGetLedger::MergeFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodeids_.MergeFrom(from.nodeids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ledgerhash();
      ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      itype_ = from.itype_;
    }
    if (cached_has_bits & 0x00000004u) {
      ltype_ = from.ltype_;
    }
    if (cached_has_bits & 0x00000008u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      querytype_ = from.querytype_;
    }
    if (cached_has_bits & 0x00000020u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000040u) {
      querydepth_ = from.querydepth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetLedger::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void TMGetLedger::Swap(TMGetLedger* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMGetLedger::InternalSwap(TMGetLedger* other) {
  using std::swap;
  nodeids_.InternalSwap(&other->nodeids_);
  ledgerhash_.Swap(&other->ledgerhash_);
  swap(itype_, other->itype_);
  swap(ltype_, other->ltype_);
  swap(ledgerseq_, other->ledgerseq_);
  swap(querytype_, other->querytype_);
  swap(requestcookie_, other->requestcookie_);
  swap(querydepth_, other->querydepth_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMGetLedger::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMLedgerData::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMLedgerData::kLedgerHashFieldNumber;
const int TMLedgerData::kLedgerSeqFieldNumber;
const int TMLedgerData::kTypeFieldNumber;
const int TMLedgerData::kNodesFieldNumber;
const int TMLedgerData::kRequestCookieFieldNumber;
const int TMLedgerData::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMLedgerData::TMLedgerData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMLedgerData();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMLedgerData)
}
TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ledgerhash()) {
    ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerData)
}

void TMLedgerData::SharedCtor() {
  _cached_size_ = 0;
  ledgerhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&requestcookie_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
  error_ = 1;
}

TMLedgerData::~TMLedgerData() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerData)
  SharedDtor();
}

void TMLedgerData::SharedDtor() {
  ledgerhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMLedgerData::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMLedgerData& TMLedgerData::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMLedgerData();
  return *internal_default_instance();
}

TMLedgerData* TMLedgerData::New(::google::protobuf::Arena* arena) const {
  TMLedgerData* n = new TMLedgerData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMLedgerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!ledgerhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*ledgerhash_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 30u) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&requestcookie_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMLedgerData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMLedgerData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ledgerHash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ledgerhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 ledgerSeq = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_ledgerseq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ledgerseq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .protocol.TMLedgerInfoType type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMLedgerInfoType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMLedgerInfoType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 requestCookie = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_requestcookie();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &requestcookie_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .protocol.TMReplyError error = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMReplyError_IsValid(value)) {
            set_error(static_cast< ::protocol::TMReplyError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMLedgerData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMLedgerData)
  return false;
#undef DO_
}

void TMLedgerData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMLedgerData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ledgerhash(), output);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ledgerseq(), output);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->nodes(static_cast<int>(i)), output);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->requestcookie(), output);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMLedgerData)
}

::google::protobuf::uint8* TMLedgerData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->nodes(static_cast<int>(i)), deterministic, target);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerData)
  return target;
}

size_t TMLedgerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (has_ledgerhash()) {
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->ledgerhash());
  }

  if (has_ledgerseq()) {
    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ledgerseq());
  }

  if (has_type()) {
    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
size_t TMLedgerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->ledgerhash());

    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ledgerseq());

    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .protocol.TMLedgerNode nodes = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->nodes(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 24u) {
    // optional uint32 requestCookie = 5;
    if (has_requestcookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMLedgerData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerData* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMLedgerData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerData)
    MergeFrom(*source);
  }
}

void TMLedgerData::MergeFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ledgerhash();
      ledgerhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ledgerhash_);
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLedgerData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->nodes())) return false;
  return true;
}

void TMLedgerData::Swap(TMLedgerData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMLedgerData::InternalSwap(TMLedgerData* other) {
  using std::swap;
  nodes_.InternalSwap(&other->nodes_);
  ledgerhash_.Swap(&other->ledgerhash_);
  swap(ledgerseq_, other->ledgerseq_);
  swap(type_, other->type_);
  swap(requestcookie_, other->requestcookie_);
  swap(error_, other->error_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMLedgerData::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TMPing::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TMPing::kTypeFieldNumber;
const int TMPing::kSeqFieldNumber;
const int TMPing::kPingTimeFieldNumber;
const int TMPing::kNetTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TMPing::TMPing()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_ripple_2eproto::InitDefaultsTMPing();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:protocol.TMPing)
}
TMPing::TMPing(const TMPing& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&nettime_) -
    reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPing)
}

void TMPing::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nettime_) -
      reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
}

TMPing::~TMPing() {
  // @@protoc_insertion_point(destructor:protocol.TMPing)
  SharedDtor();
}

void TMPing::SharedDtor() {
}

void TMPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TMPing::descriptor() {
  ::protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TMPing& TMPing::default_instance() {
  ::protobuf_ripple_2eproto::InitDefaultsTMPing();
  return *internal_default_instance();
}

TMPing* TMPing::New(::google::protobuf::Arena* arena) const {
  TMPing* n = new TMPing;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TMPing::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nettime_) -
        reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TMPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protocol.TMPing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .protocol.TMPing.pingType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::protocol::TMPing_pingType_IsValid(value)) {
            set_type(static_cast< ::protocol::TMPing_pingType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 seq = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_seq();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 pingTime = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_pingtime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pingtime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 netTime = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_nettime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nettime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protocol.TMPing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protocol.TMPing)
  return false;
#undef DO_
}

void TMPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protocol.TMPing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->seq(), output);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->pingtime(), output);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->nettime(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:protocol.TMPing)
}

::google::protobuf::uint8* TMPing::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->nettime(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPing)
  return target;
}

size_t TMPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPing)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .protocol.TMPing.pingType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[0 / 32] & 14u) {
    // optional uint32 seq = 2;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seq());
    }

    // optional uint64 pingTime = 3;
    if (has_pingtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pingtime());
    }

    // optional uint64 netTime = 4;
    if (has_nettime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nettime());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TMPing::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPing* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TMPing>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPing)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPing)
    MergeFrom(*source);
  }
}

void TMPing::MergeFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000004u) {
      pingtime_ = from.pingtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      nettime_ = from.nettime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPing::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPing::CopyFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void TMPing::Swap(TMPing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TMPing::InternalSwap(TMPing* other) {
  using std::swap;
  swap(type_, other->type_);
  swap(seq_, other->seq_);
  swap(pingtime_, other->pingtime_);
  swap(nettime_, other->nettime_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TMPing::GetMetadata() const {
  protobuf_ripple_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_ripple_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol

// @@protoc_insertion_point(global_scope)
